{"version":3,"sources":["../../src/core/crypto/multiEd25519.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { PublicKey, Signature } from \"./asymmetricCrypto\";\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializer } from \"../../bcs/serializer\";\nimport { Ed25519PublicKey, Ed25519Signature } from \"./ed25519\";\nimport { Hex } from \"../hex\";\nimport { HexInput } from \"../../types\";\n\n/**\n * Represents the public key of a K-of-N Ed25519 multi-sig transaction.\n */\nexport class MultiEd25519PublicKey extends PublicKey {\n  /**\n   * Maximum number of public keys supported\n   */\n  static readonly MAX_KEYS = 32;\n\n  /**\n   * Minimum number of public keys needed\n   */\n  static readonly MIN_KEYS = 2;\n\n  /**\n   * Minimum threshold for the number of valid signatures required\n   */\n  static readonly MIN_THRESHOLD = 1;\n\n  /**\n   * List of Ed25519 public keys for this MultiEd25519PublicKey\n   */\n  public readonly publicKeys: Ed25519PublicKey[];\n\n  /**\n   * The minimum number of valid signatures required, for the number of public keys specified\n   */\n  public readonly threshold: number;\n\n  /**\n   * Public key for a K-of-N multi-sig transaction. A K-of-N multi-sig transaction means that for such a\n   * transaction to be executed, at least K out of the N authorized signers have signed the transaction\n   * and passed the check conducted by the chain.\n   *\n   * @see {@link\n   * https://aptos.dev/integration/creating-a-signed-transaction/ | Creating a Signed Transaction}\n   *\n   * @param args.publicKeys A list of public keys\n   * @param args.threshold At least \"threshold\" signatures must be valid\n   */\n  constructor(args: { publicKeys: Ed25519PublicKey[]; threshold: number }) {\n    super();\n\n    const { publicKeys, threshold } = args;\n\n    // Validate number of public keys\n    if (publicKeys.length > MultiEd25519PublicKey.MAX_KEYS || publicKeys.length < MultiEd25519PublicKey.MIN_KEYS) {\n      throw new Error(\n        `Must have between ${MultiEd25519PublicKey.MIN_KEYS} and ${MultiEd25519PublicKey.MAX_KEYS} public keys, inclusive`,\n      );\n    }\n\n    // Validate threshold: must be between 1 and the number of public keys, inclusive\n    if (threshold < MultiEd25519PublicKey.MIN_THRESHOLD || threshold > publicKeys.length) {\n      throw new Error(\n        `Threshold must be between ${MultiEd25519PublicKey.MIN_THRESHOLD} and ${publicKeys.length}, inclusive`,\n      );\n    }\n\n    this.publicKeys = publicKeys;\n    this.threshold = threshold;\n  }\n\n  /**\n   * Converts a PublicKeys into Uint8Array (bytes) with: bytes = p1_bytes | ... | pn_bytes | threshold\n   */\n  toUint8Array(): Uint8Array {\n    const bytes = new Uint8Array(this.publicKeys.length * Ed25519PublicKey.LENGTH + 1);\n    this.publicKeys.forEach((k: Ed25519PublicKey, i: number) => {\n      bytes.set(k.toUint8Array(), i * Ed25519PublicKey.LENGTH);\n    });\n\n    bytes[this.publicKeys.length * Ed25519PublicKey.LENGTH] = this.threshold;\n\n    return bytes;\n  }\n\n  toString(): string {\n    return Hex.fromHexInput(this.toUint8Array()).toString();\n  }\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars\n  verifySignature(args: { message: HexInput; signature: MultiEd25519Signature }): boolean {\n    throw new Error(\"TODO - Method not implemented.\");\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): MultiEd25519PublicKey {\n    const bytes = deserializer.deserializeBytes();\n    const threshold = bytes[bytes.length - 1];\n\n    const keys: Ed25519PublicKey[] = [];\n\n    for (let i = 0; i < bytes.length - 1; i += Ed25519PublicKey.LENGTH) {\n      const begin = i;\n      keys.push(new Ed25519PublicKey(bytes.subarray(begin, begin + Ed25519PublicKey.LENGTH)));\n    }\n    return new MultiEd25519PublicKey({ publicKeys: keys, threshold });\n  }\n}\n\n/**\n * Represents the signature of a K-of-N Ed25519 multi-sig transaction.\n */\nexport class MultiEd25519Signature extends Signature {\n  /**\n   * Maximum number of Ed25519 signatures supported\n   */\n  static MAX_SIGNATURES_SUPPORTED = 32;\n\n  /**\n   * Number of bytes in the bitmap representing who signed the transaction (32-bits)\n   */\n  static BITMAP_LEN: number = 4;\n\n  /**\n   * The list of underlying Ed25519 signatures\n   */\n  public readonly signatures: Ed25519Signature[];\n\n  /**\n   * 32-bit Bitmap representing who signed the transaction\n   *\n   * This is represented where each public key can be masked to determine whether the message was signed by that key.\n   */\n  public readonly bitmap: Uint8Array;\n\n  /**\n   * Signature for a K-of-N multi-sig transaction.\n   *\n   * @see {@link\n   * https://aptos.dev/integration/creating-a-signed-transaction/#multisignature-transactions | Creating a Signed Transaction}\n   *\n   * @param args.signatures A list of signatures\n   * @param args.bitmap 4 bytes, at most 32 signatures are supported. If Nth bit value is `1`, the Nth\n   * signature should be provided in `signatures`. Bits are read from left to right\n   */\n  constructor(args: { signatures: Ed25519Signature[]; bitmap: Uint8Array }) {\n    super();\n\n    const { signatures, bitmap } = args;\n    if (bitmap.length !== MultiEd25519Signature.BITMAP_LEN) {\n      throw new Error(`\"bitmap\" length should be ${MultiEd25519Signature.BITMAP_LEN}`);\n    }\n\n    if (signatures.length > MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED) {\n      throw new Error(\n        `The number of signatures cannot be greater than ${MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED}`,\n      );\n    }\n\n    this.signatures = signatures;\n    this.bitmap = bitmap;\n  }\n\n  /**\n   * Converts a MultiSignature into Uint8Array (bytes) with `bytes = s1_bytes | ... | sn_bytes | bitmap`\n   */\n  toUint8Array(): Uint8Array {\n    const bytes = new Uint8Array(this.signatures.length * Ed25519Signature.LENGTH + MultiEd25519Signature.BITMAP_LEN);\n    this.signatures.forEach((k: Ed25519Signature, i: number) => {\n      bytes.set(k.toUint8Array(), i * Ed25519Signature.LENGTH);\n    });\n\n    bytes.set(this.bitmap, this.signatures.length * Ed25519Signature.LENGTH);\n\n    return bytes;\n  }\n\n  toString(): string {\n    return Hex.fromHexInput(this.toUint8Array()).toString();\n  }\n\n  /**\n   * Helper method to create a bitmap out of the specified bit positions\n   * @param args.bits The bitmap positions that should be set. A position starts at index 0.\n   * Valid position should range between 0 and 31.\n   * @example\n   * Here's an example of valid `bits`\n   * ```\n   * [0, 2, 31]\n   * ```\n   * `[0, 2, 31]` means the 1st, 3rd and 32nd bits should be set in the bitmap.\n   * The result bitmap should be 0b1010000000000000000000000000001\n   *\n   * @returns bitmap that is 32bit long\n   */\n  static createBitmap(args: { bits: number[] }): Uint8Array {\n    const { bits } = args;\n    // Bits are read from left to right. e.g. 0b10000000 represents the first bit is set in one byte.\n    // The decimal value of 0b10000000 is 128.\n    const firstBitInByte = 128;\n    const bitmap = new Uint8Array([0, 0, 0, 0]);\n\n    // Check if duplicates exist in bits\n    const dupCheckSet = new Set();\n\n    bits.forEach((bit: number) => {\n      if (bit >= MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED) {\n        throw new Error(`Cannot have a signature larger than ${MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED - 1}.`);\n      }\n\n      if (dupCheckSet.has(bit)) {\n        throw new Error(\"Duplicate bits detected.\");\n      }\n\n      dupCheckSet.add(bit);\n\n      const byteOffset = Math.floor(bit / 8);\n\n      let byte = bitmap[byteOffset];\n\n      // eslint-disable-next-line no-bitwise\n      byte |= firstBitInByte >> bit % 8;\n\n      bitmap[byteOffset] = byte;\n    });\n\n    return bitmap;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): MultiEd25519Signature {\n    const bytes = deserializer.deserializeBytes();\n    const bitmap = bytes.subarray(bytes.length - 4);\n\n    const signatures: Ed25519Signature[] = [];\n\n    for (let i = 0; i < bytes.length - bitmap.length; i += Ed25519Signature.LENGTH) {\n      const begin = i;\n      signatures.push(new Ed25519Signature(bytes.subarray(begin, begin + Ed25519Signature.LENGTH)));\n    }\n    return new MultiEd25519Signature({ signatures, bitmap });\n  }\n}\n"],"mappings":"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","names":["_MultiEd25519PublicKey","PublicKey","args","publicKeys","threshold","bytes","Ed25519PublicKey","k","i","Hex","serializer","deserializer","keys","begin","MultiEd25519PublicKey","_MultiEd25519Signature","Signature","signatures","bitmap","Ed25519Signature","bits","firstBitInByte","dupCheckSet","bit","byteOffset","byte","MultiEd25519Signature"]}
{"version":3,"sources":["../../src/core/account.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountAddress } from \"./accountAddress\";\nimport { AuthenticationKey } from \"./authenticationKey\";\nimport { PrivateKey, PublicKey, Signature } from \"./crypto/asymmetricCrypto\";\nimport { Ed25519PrivateKey, Ed25519PublicKey } from \"./crypto/ed25519\";\nimport { MultiEd25519PublicKey } from \"./crypto/multiEd25519\";\nimport { Secp256k1PrivateKey, Secp256k1PublicKey } from \"./crypto/secp256k1\";\nimport { Hex } from \"./hex\";\nimport { GenerateAccount, HexInput, SigningScheme, SigningSchemeInput } from \"../types\";\nimport { AnyPublicKey } from \"./crypto/anyPublicKey\";\n\n/**\n * Class for creating and managing account on Aptos network\n *\n * Use this class to create accounts, sign transactions, and more.\n * Note: Creating an account instance does not create the account on-chain.\n *\n * Since [AIP-55](https://github.com/aptos-foundation/AIPs/pull/263) Aptos supports\n * `Legacy` and `Unified` authentications.\n *\n * @Legacy includes `ED25519` and `MultiED25519`\n * @Unified includes `SingleSender` and `MultiSender`, where currently\n * `SingleSender` supports `ED25519` and `Secp256k1`, and `MultiSender` supports\n * `MultiED25519`.\n *\n * In TypeScript SDK, we support all of these options:\n *\n * @generate default to generate Legacy Ed25519 keys, with an optional `legacy` boolean argument\n * that lets you generate new keys conforming to the Unified authentication.\n *\n * @fromPrivateKey derives an account by a provided private key and address, with an optional\n * `legacy` boolean argument that lets you generate new keys conforming to the Unified authentication.\n *\n * @fromDerivationPath derives an account with bip44 path and mnemonics,\n *\n */\nexport class Account {\n  /**\n   * Public key associated with the account\n   */\n  readonly publicKey: PublicKey;\n\n  /**\n   * Private key associated with the account\n   */\n  readonly privateKey: PrivateKey;\n\n  /**\n   * Account address associated with the account\n   */\n  readonly accountAddress: AccountAddress;\n\n  /**\n   * Signing scheme used to sign transactions\n   */\n  readonly signingScheme: SigningScheme;\n\n  /**\n   * constructor for Account\n   *\n   * Need to update this to use the new crypto library if new schemes are added.\n   *\n   * @param args.privateKey PrivateKey - private key of the account\n   * @param args.address AccountAddress - address of the account\n   * @param args.legacy optional. If set to true, the keypair authentication keys will be derived with a Legacy scheme.\n   * Defaults to deriving an authentication key with a Unified scheme\n   *\n   * This method is private because it should only be called by the factory static methods.\n   * @returns Account\n   */\n  private constructor(args: { privateKey: PrivateKey; address: AccountAddress; legacy?: boolean }) {\n    const { privateKey, address, legacy } = args;\n    const useLegacy = legacy ?? true;\n\n    // Derive the public key from the private key\n    this.publicKey = privateKey.publicKey();\n\n    // Derive the signing scheme from the public key\n    if (this.publicKey instanceof Ed25519PublicKey) {\n      if (useLegacy) {\n        this.signingScheme = SigningScheme.Ed25519;\n      } else {\n        this.publicKey = new AnyPublicKey(this.publicKey);\n        this.signingScheme = SigningScheme.SingleKey;\n      }\n    } else if (this.publicKey instanceof MultiEd25519PublicKey) {\n      this.signingScheme = SigningScheme.MultiEd25519;\n    } else if (this.publicKey instanceof Secp256k1PublicKey) {\n      this.publicKey = new AnyPublicKey(this.publicKey);\n      this.signingScheme = SigningScheme.SingleKey;\n    } else {\n      throw new Error(\"Can not create new Account, unsupported public key type\");\n    }\n\n    this.privateKey = privateKey;\n    this.accountAddress = address;\n  }\n\n  /**\n   * Derives an account with random private key and address.\n   *\n   * Default generation is using the Legacy ED25519 key\n   *\n   * @param args optional. Unify GenerateAccount type for Legacy and Unified keys\n   *\n   * Account input type to generate an account using Legacy\n   * Ed25519 or MultiEd25519 keys or without a specified `scheme`.\n   * ```\n   * GenerateAccountWithLegacyKey = {\n   *  scheme?: SigningSchemeInput.Ed25519 | SigningSchemeInput.MultiEd25519;\n   *  legacy: true;\n   * };\n   * ```\n   *\n   * Account input type to generate an account using Unified\n   * Secp256k1Ecdsa key\n   * In this case `legacy` is always false\n   * ```\n   * GenerateAccountWithUnifiedKey = {\n   *  scheme: SigningSchemeInput.Secp256k1Ecdsa;\n   *  legacy?: false;\n   * };\n   * ```\n   *\n   * @returns Account with the given signing scheme\n   */\n  static generate(args?: GenerateAccount): Account {\n    const useLegacy = args?.legacy ?? true;\n\n    let privateKey: PrivateKey;\n    let publicKey: PublicKey;\n\n    switch (args?.scheme) {\n      case SigningSchemeInput.Secp256k1Ecdsa:\n        privateKey = Secp256k1PrivateKey.generate();\n        publicKey = new AnyPublicKey(privateKey.publicKey());\n        break;\n      default:\n        privateKey = Ed25519PrivateKey.generate();\n        if (useLegacy === false) {\n          publicKey = new AnyPublicKey(privateKey.publicKey());\n        } else {\n          publicKey = privateKey.publicKey();\n        }\n    }\n    const authKey = AuthenticationKey.fromPublicKey({ publicKey });\n\n    const address = authKey.derivedAddress();\n    return new Account({ privateKey, address, legacy: args?.legacy });\n  }\n\n  /**\n   * Instantiates an account given a private key.\n   *\n   * This is used as a local calculation and therefore is used to instantiate an `Account`\n   * that has not had its authentication key rotated.\n   *\n   * @param privateKey PrivateKey - private key of the account\n   * @param args.legacy optional. If set to false, the keypair generated is a Unified keypair. Defaults\n   * to generating a Legacy Ed25519 keypair\n   *\n   * @returns Account\n   */\n  static fromPrivateKey(args: { privateKey: PrivateKey; legacy?: boolean }): Account {\n    const { privateKey, legacy } = args;\n    const useLegacy = legacy ?? true;\n\n    let publicKey;\n    if (privateKey instanceof Secp256k1PrivateKey) {\n      // Secp256k1 single sender\n      publicKey = new AnyPublicKey(privateKey.publicKey());\n    } else if (privateKey instanceof Ed25519PrivateKey) {\n      // legacy Ed25519\n      if (useLegacy) {\n        publicKey = privateKey.publicKey();\n      } else {\n        // Ed25519 single sender\n        publicKey = new AnyPublicKey(privateKey.publicKey());\n      }\n    } else {\n      throw new Error(`Unsupported private key ${privateKey}`);\n    }\n\n    const authKey = AuthenticationKey.fromPublicKey({ publicKey });\n    const address = authKey.derivedAddress();\n    return new Account({ privateKey, address, legacy: useLegacy });\n  }\n\n  /**\n   * Instantiates an account given a private key and a specified account address.\n   * This is primarily used to instantiate an `Account` that has had its authentication key rotated.\n   *\n   * @param args.privateKey PrivateKey - the underlying private key for the account\n   * @param args.address AccountAddress - The account address the `Account` will sign for\n   * @param args.legacy optional. If set to false, the keypair generated is a Unified keypair. Defaults\n   * to generating a Legacy Ed25519 keypair\n   *\n   * @returns Account\n   */\n  static fromPrivateKeyAndAddress(args: {\n    privateKey: PrivateKey;\n    address: AccountAddress;\n    legacy?: boolean;\n  }): Account {\n    const { privateKey, address, legacy } = args;\n    return new Account({ privateKey, address, legacy });\n  }\n\n  /**\n   * Derives an account with bip44 path and mnemonics,\n   *\n   * @param args.scheme The signing scheme to derive with\n   * @param args.path the BIP44 derive hardened path (e.g. m/44'/637'/0'/0'/0') for Ed25519,\n   * or non-hardened path (e.g. m/44'/637'/0'/0/0) for secp256k1\n   * Detailed description: {@link https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki}\n   * @param args.mnemonic the mnemonic seed phrase of the account\n   * @param args.legacy optional. If set to false, the keypair generated is a Unified keypair. Defaults\n   * to generating a Legacy Ed25519 keypair\n   *\n   * @returns Account\n   */\n  static fromDerivationPath(args: {\n    scheme: SigningSchemeInput;\n    path: string;\n    mnemonic: string;\n    legacy?: boolean;\n  }): Account {\n    const { path, mnemonic, scheme, legacy } = args;\n    let privateKey: PrivateKey;\n    switch (scheme) {\n      case SigningSchemeInput.Secp256k1Ecdsa:\n        privateKey = Secp256k1PrivateKey.fromDerivationPath(path, mnemonic);\n        break;\n      case SigningSchemeInput.Ed25519:\n        privateKey = Ed25519PrivateKey.fromDerivationPath(path, mnemonic);\n        break;\n      default:\n        throw new Error(`Unsupported scheme ${scheme}`);\n    }\n    return Account.fromPrivateKey({ privateKey, legacy });\n  }\n\n  /**\n   * This key enables account owners to rotate their private key(s)\n   * associated with the account without changing the address that hosts their account.\n   * See here for more info: {@link https://aptos.dev/concepts/accounts#single-signer-authentication}\n   *\n   * @param args.publicKey PublicKey - public key of the account\n   * @returns The authentication key for the associated account\n   */\n  static authKey(args: { publicKey: PublicKey }): AuthenticationKey {\n    const { publicKey } = args;\n    return AuthenticationKey.fromPublicKey({ publicKey });\n  }\n\n  /**\n   * Sign the given message with the private key.\n   *\n   * TODO: Add sign transaction or specific types\n   *\n   * @param data in HexInput format\n   * @returns Signature\n   */\n  sign(data: HexInput): Signature {\n    return this.privateKey.sign(data);\n  }\n\n  /**\n   * Verify the given message and signature with the public key.\n   *\n   * @param args.message raw message data in HexInput format\n   * @param args.signature signed message Signature\n   * @returns\n   */\n  verifySignature(args: { message: HexInput; signature: Signature }): boolean {\n    const { message, signature } = args;\n    const rawMessage = Hex.fromHexInput(message).toUint8Array();\n    return this.publicKey.verifySignature({ message: rawMessage, signature });\n  }\n}\n"],"mappings":"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","names":["Account","_Account","args","privateKey","address","legacy","useLegacy","Ed25519PublicKey","AnyPublicKey","MultiEd25519PublicKey","Secp256k1PublicKey","publicKey","Secp256k1PrivateKey","Ed25519PrivateKey","AuthenticationKey","path","mnemonic","scheme","data","message","signature","rawMessage","Hex"]}
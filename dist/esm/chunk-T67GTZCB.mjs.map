{"version":3,"sources":["../../src/transactions/transactionBuilder/remoteAbi.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { parseTypeTag } from \"../typeTag/parser\";\nimport { TypeTag, TypeTagStruct } from \"../typeTag\";\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport { EntryFunctionArgumentTypes, SimpleEntryFunctionArgumentTypes, EntryFunctionABI } from \"../types\";\nimport { Bool, MoveOption, MoveString, MoveVector, U128, U16, U256, U32, U64, U8 } from \"../../bcs\";\nimport { AccountAddress, Hex } from \"../../core\";\nimport { getModule } from \"../../internal/account\";\nimport {\n  findFirstNonSignerArg,\n  isBcsAddress,\n  isBcsBool,\n  isBcsFixedBytes,\n  isBcsString,\n  isBcsU128,\n  isBcsU16,\n  isBcsU256,\n  isBcsU32,\n  isBcsU64,\n  isBcsU8,\n  isBool,\n  isLargeNumber,\n  isNull,\n  isNumber,\n  isString,\n  throwTypeMismatch,\n} from \"./helpers\";\n\n/**\n * Convert type arguments to only type tags, allowing for string representations of type tags\n */\nexport function standardizeTypeTags(typeArguments?: Array<TypeTag | string>): Array<TypeTag> {\n  return (\n    typeArguments?.map((typeArg: string | TypeTag): TypeTag => {\n      // Convert to TypeTag if it's a string representation\n      if (isString(typeArg)) {\n        return parseTypeTag(typeArg);\n      }\n      return typeArg;\n    }) ?? []\n  );\n}\n\n/**\n * Fetches the ABI for an entry function from the module\n *\n * @param moduleAddress\n * @param moduleName\n * @param functionName\n * @param aptosConfig\n */\nexport async function fetchEntryFunctionAbi(\n  moduleAddress: string,\n  moduleName: string,\n  functionName: string,\n  aptosConfig: AptosConfig,\n): Promise<EntryFunctionABI> {\n  // This fetch from the API is currently cached\n  const module = await getModule({ aptosConfig, accountAddress: moduleAddress, moduleName });\n\n  const functionAbi = module.abi?.exposed_functions.find((func) => func.name === functionName);\n\n  // If there's no ABI, then the function is invalid\n  if (!functionAbi) {\n    throw new Error(`Could not find entry function ABI for '${moduleAddress}::${moduleName}::${functionName}'`);\n  }\n\n  // Non-entry functions also can't be used\n  if (!functionAbi.is_entry) {\n    throw new Error(`'${moduleAddress}::${moduleName}::${functionName}' is not an entry function`);\n  }\n\n  // Remove the signer arguments\n  const first = findFirstNonSignerArg(functionAbi);\n  const params: TypeTag[] = [];\n  for (let i = first; i < functionAbi.params.length; i += 1) {\n    params.push(parseTypeTag(functionAbi.params[i], { allowGenerics: true }));\n  }\n\n  return {\n    typeParameters: functionAbi.generic_type_params,\n    parameters: params,\n  };\n}\n\n/**\n * Converts a non-BCS encoded argument into BCS encoded, if necessary\n * @param functionName\n * @param functionAbi\n * @param arg\n * @param position\n */\nexport function convertArgument(\n  functionName: string,\n  functionAbi: EntryFunctionABI,\n  arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n) {\n  // Ensure not too many arguments\n  if (position >= functionAbi.parameters.length) {\n    throw new Error(`Too many arguments for '${functionName}', expected ${functionAbi.parameters.length}`);\n  }\n\n  // If the argument is bcs encoded, we can just use it directly\n  if (\n    isBcsBool(arg) ||\n    isBcsU8(arg) ||\n    isBcsU16(arg) ||\n    isBcsU32(arg) ||\n    isBcsU64(arg) ||\n    isBcsU128(arg) ||\n    isBcsU256(arg) ||\n    isBcsAddress(arg) ||\n    isBcsString(arg) ||\n    isBcsFixedBytes(arg) ||\n    arg instanceof MoveVector ||\n    arg instanceof MoveOption\n  ) {\n    // Ensure the type matches the ABI\n    checkType(functionAbi, arg, position);\n    return arg;\n  }\n\n  // If it is not BCS encoded, we will need to convert it with the ABI\n  return parseArg(arg, functionAbi.parameters[position], position, genericTypeParams);\n}\n\n/**\n * Parses a non-BCS encoded argument into a BCS encoded argument recursively\n * @param arg\n * @param param\n * @param position\n * @param genericTypeParams\n */\nfunction parseArg(\n  arg: SimpleEntryFunctionArgumentTypes,\n  param: TypeTag,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n): EntryFunctionArgumentTypes {\n  if (param.isBool()) {\n    if (isBool(arg)) {\n      return new Bool(arg);\n    }\n    throwTypeMismatch(\"boolean\", position);\n  }\n  // TODO: support uint8array?\n  if (param.isAddress()) {\n    if (isString(arg)) {\n      return AccountAddress.fromStringRelaxed(arg);\n    }\n    throwTypeMismatch(\"string\", position);\n  }\n  if (param.isU8()) {\n    if (isNumber(arg)) {\n      return new U8(arg);\n    }\n    throwTypeMismatch(\"number\", position);\n  }\n  if (param.isU16()) {\n    if (isNumber(arg)) {\n      return new U16(arg);\n    }\n    throwTypeMismatch(\"number\", position);\n  }\n  if (param.isU32()) {\n    if (isNumber(arg)) {\n      return new U32(arg);\n    }\n    throwTypeMismatch(\"number\", position);\n  }\n  if (param.isU64()) {\n    if (isLargeNumber(arg)) {\n      return new U64(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n  if (param.isU128()) {\n    if (isLargeNumber(arg)) {\n      return new U128(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n  if (param.isU256()) {\n    if (isLargeNumber(arg)) {\n      return new U256(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n\n  // Generic needs to use the sub-type\n  if (param.isGeneric()) {\n    const genericIndex = param.value;\n    if (genericIndex < 0 || genericIndex >= genericTypeParams.length) {\n      throw new Error(`Generic argument ${param.toString()} is invalid for argument ${position}`);\n    }\n\n    parseArg(arg, genericTypeParams[genericIndex], position, genericTypeParams);\n  }\n\n  // We have to special case some vectors for Vector<u8>\n  if (param.isVector()) {\n    // Check special case for Vector<u8>\n    if (param.value.isU8() && isString(arg)) {\n      // TODO: Improve message when hex is invalid\n      return MoveVector.U8(Hex.fromHexInput(arg).toUint8Array());\n    }\n\n    if (Array.isArray(arg)) {\n      return new MoveVector(arg.map((item) => parseArg(item, param.value, position, genericTypeParams)));\n    }\n\n    throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);\n  }\n\n  // Handle structs as they're more complex\n  if (param.isStruct()) {\n    if (param.isString()) {\n      if (isString(arg)) {\n        return new MoveString(arg);\n      }\n      throwTypeMismatch(\"string\", position);\n    }\n    if (param.isObject()) {\n      // The inner type of Object doesn't matter, since it's just syntactic sugar\n      if (isString(arg)) {\n        return AccountAddress.fromStringRelaxed(arg);\n      }\n      throwTypeMismatch(\"string\", position);\n    }\n\n    if (param.isOption()) {\n      // Empty option must be handled specially\n      if (isNull(arg)) {\n        // Note: This is a placeholder U8 type, and does not match the actual type, as that can't be dynamically grabbed\n        return new MoveOption<U8>(null);\n      }\n\n      return new MoveOption(parseArg(arg, param.value.typeArgs[0], position, genericTypeParams));\n    }\n\n    throw new Error(`Unsupported struct input type for argument ${position}, type '${param.toString()}'`);\n  }\n\n  throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);\n}\n\n/**\n * Checks that the type of an already BCS encoded argument matches the ABI\n * @param functionAbi\n * @param arg\n * @param position\n */\nfunction checkType(functionAbi: EntryFunctionABI, arg: EntryFunctionArgumentTypes, position: number) {\n  const param = functionAbi.parameters[position];\n  if (param.isBool()) {\n    if (isBcsBool(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"Bool\", position);\n  }\n  if (param.isAddress()) {\n    if (isBcsAddress(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"AccountAddress\", position);\n  }\n  if (param.isU8()) {\n    if (isBcsU8(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U8\", position);\n  }\n  if (param.isU16()) {\n    if (isBcsU16(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U16\", position);\n  }\n  if (param.isU32()) {\n    if (isBcsU32(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U32\", position);\n  }\n  if (param.isU64()) {\n    if (isBcsU64(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U64\", position);\n  }\n  if (param.isU128()) {\n    if (isBcsU128(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U128\", position);\n  }\n  if (param.isU256()) {\n    if (isBcsU256(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U256\", position);\n  }\n  if (param.isVector()) {\n    if (arg instanceof MoveVector) {\n      // TODO: More introspection to verify the type\n      return;\n    }\n    throwTypeMismatch(\"MoveVector\", position);\n  }\n\n  // Handle structs as they're more complex\n  if (param instanceof TypeTagStruct) {\n    if (param.isString()) {\n      if (isBcsString(arg)) {\n        return;\n      }\n      throwTypeMismatch(\"MoveString\", position);\n    }\n    if (param.isObject()) {\n      if (isBcsAddress(arg)) {\n        return;\n      }\n      throwTypeMismatch(\"AccountAddress\", position);\n    }\n    if (param.isOption()) {\n      if (arg instanceof MoveOption) {\n        // TODO: more introspection for the type\n        return;\n      }\n      throwTypeMismatch(\"MoveOption\", position);\n    }\n  }\n\n  throw new Error(`Type mismatch for argument ${position}, expected '${param.toString()}'`);\n}\n"],"mappings":"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","names":["standardizeTypeTags","typeArguments","typeArg","isString","parseTypeTag","fetchEntryFunctionAbi","moduleAddress","moduleName","functionName","aptosConfig","functionAbi","getModule","func","first","findFirstNonSignerArg","params","i","convertArgument","arg","position","genericTypeParams","isBcsBool","isBcsU8","isBcsU16","isBcsU32","isBcsU64","isBcsU128","isBcsU256","isBcsAddress","isBcsString","isBcsFixedBytes","MoveVector","MoveOption","checkType","parseArg","param","isBool","Bool","throwTypeMismatch","AccountAddress","isNumber","U8","U16","U32","isLargeNumber","U64","U128","U256","genericIndex","Hex","item","MoveString","isNull","TypeTagStruct"]}
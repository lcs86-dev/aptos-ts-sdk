{"version":3,"sources":["../../src/internal/transactionSubmission.ts"],"sourcesContent":["/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/transaction_submission}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * transaction_submission namespace and without having a dependency cycle error.\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { MoveVector, U8 } from \"../bcs\";\nimport { postAptosFullNode } from \"../client\";\nimport { Account } from \"../core/account\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { PrivateKey } from \"../core/crypto\";\nimport { AccountAuthenticator } from \"../transactions/authenticator/account\";\nimport { RotationProofChallenge } from \"../transactions/instances/rotationProofChallenge\";\nimport {\n  buildTransaction,\n  generateTransactionPayload,\n  generateSignedTransactionForSimulation,\n  generateSignedTransaction,\n  sign,\n} from \"../transactions/transactionBuilder/transactionBuilder\";\nimport {\n  InputGenerateTransactionData,\n  AnyRawTransaction,\n  InputSimulateTransactionData,\n  InputGenerateTransactionOptions,\n  SingleSignerTransaction,\n  InputGenerateTransactionPayloadDataWithRemoteABI,\n  InputSubmitTransactionData,\n  InputGenerateMultiAgentRawTransactionData,\n  InputGenerateSingleSignerRawTransactionData,\n  MultiAgentTransaction,\n  AnyTransactionPayloadInstance,\n} from \"../transactions/types\";\nimport { getInfo } from \"./account\";\nimport { UserTransactionResponse, PendingTransactionResponse, MimeType, HexInput, TransactionResponse } from \"../types\";\n\n/**\n * We are defining function signatures, each with its specific input and output.\n * These are the possible function signature for `generateTransaction` function.\n * When we call `generateTransaction` function with the relevant type properties,\n * Typescript can infer the return type based on the appropriate function overload.\n */\nexport async function generateTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateSingleSignerRawTransactionData,\n): Promise<SingleSignerTransaction>;\nexport async function generateTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateMultiAgentRawTransactionData,\n): Promise<MultiAgentTransaction>;\n/**\n * Generates any transaction by passing in the required arguments\n *\n * @param args.sender The transaction sender's account address as a AccountAddressInput\n * @param args.data EntryFunctionData | ScriptData | MultiSigData\n * @param args.feePayerAddress optional. For a fee payer (aka sponsored) transaction\n * @param args.secondarySignerAddresses optional. For a multi-agent or fee payer (aka sponsored) transactions\n * @param args.options optional. GenerateTransactionOptions type\n *\n * @example\n * For a single signer entry function\n * move function name, move function type arguments, move function arguments\n * `\n * data: {\n *  function:\"0x1::aptos_account::transfer\",\n *  typeArguments:[]\n *  functionArguments :[receiverAddress,10]\n * }\n * `\n *\n * @example\n * For a single signer script function\n * module bytecode, move function type arguments, move function arguments\n * ```\n * data: {\n *  bytecode:\"0x001234567\",\n *  typeArguments:[],\n *  functionArguments :[receiverAddress,10]\n * }\n * ```\n *\n * @return An instance of a RawTransaction, plus optional secondary/fee payer addresses\n * ```\n * {\n *  rawTransaction: RawTransaction,\n *  secondarySignerAddresses? : Array<AccountAddress>,\n *  feePayerAddress?: AccountAddress\n * }\n * ```\n */\nexport async function generateTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateTransactionData,\n): Promise<AnyRawTransaction> {\n  const { aptosConfig, sender, data, options } = args;\n\n  // Merge in aptosConfig for remote ABI on non-script payloads\n  let generateTransactionPayloadData: InputGenerateTransactionPayloadDataWithRemoteABI;\n  let payload: AnyTransactionPayloadInstance;\n  if (\"bytecode\" in data) {\n    generateTransactionPayloadData = data;\n    payload = await generateTransactionPayload(generateTransactionPayloadData);\n  } else if (\"multisigAddress\" in data) {\n    generateTransactionPayloadData = {\n      aptosConfig,\n      multisigAddress: data.multisigAddress,\n      function: data.function,\n      functionArguments: data.functionArguments,\n      typeArguments: data.typeArguments,\n    };\n    payload = await generateTransactionPayload(generateTransactionPayloadData);\n  } else {\n    generateTransactionPayloadData = {\n      aptosConfig,\n      function: data.function,\n      functionArguments: data.functionArguments,\n      typeArguments: data.typeArguments,\n    };\n    payload = await generateTransactionPayload(generateTransactionPayloadData);\n  }\n\n  let feePayerAddress;\n  if (isFeePayerTransactionInput(args)) {\n    feePayerAddress = AccountAddress.ZERO.toString();\n  }\n\n  if (isMultiAgentTransactionInput(args)) {\n    const { secondarySignerAddresses } = args;\n    return buildTransaction({\n      aptosConfig,\n      sender,\n      payload,\n      options,\n      secondarySignerAddresses,\n      feePayerAddress,\n    });\n  }\n\n  return buildTransaction({\n    aptosConfig,\n    sender,\n    payload,\n    options,\n    feePayerAddress,\n  });\n}\n\nfunction isFeePayerTransactionInput(data: InputGenerateTransactionData): boolean {\n  return data.withFeePayer === true;\n}\n\nfunction isMultiAgentTransactionInput(\n  data: InputGenerateTransactionData,\n): data is InputGenerateMultiAgentRawTransactionData {\n  return \"secondarySignerAddresses\" in data;\n}\n\n/**\n * Sign a transaction that can later be submitted to chain\n *\n * @param args.signer The signer account to sign the transaction\n * @param args.transaction An instance of a RawTransaction, plus optional secondary/fee payer addresses\n * ```\n * {\n *  rawTransaction: RawTransaction,\n *  secondarySignerAddresses? : Array<AccountAddress>,\n *  feePayerAddress?: AccountAddress\n * }\n * ```\n *\n * @return The signer AccountAuthenticator\n */\nexport function signTransaction(args: { signer: Account; transaction: AnyRawTransaction }): AccountAuthenticator {\n  const accountAuthenticator = sign({ ...args });\n  return accountAuthenticator;\n}\n\n/**\n * Simulates a transaction before singing it.\n *\n * @param args.signerPublicKey The signer public key\n * @param args.transaction The raw transaction to simulate\n * @param args.secondarySignersPublicKeys optional. For when the transaction is a multi signers transaction\n * @param args.feePayerPublicKey optional. For when the transaction is a fee payer (aka sponsored) transaction\n * @param args.options optional. A config to simulate the transaction with\n */\nexport async function simulateTransaction(\n  args: { aptosConfig: AptosConfig } & InputSimulateTransactionData,\n): Promise<Array<UserTransactionResponse>> {\n  const { aptosConfig, transaction, signerPublicKey, secondarySignersPublicKeys, feePayerPublicKey, options } = args;\n\n  const signedTransaction = generateSignedTransactionForSimulation({\n    transaction,\n    signerPublicKey,\n    secondarySignersPublicKeys,\n    feePayerPublicKey,\n    options,\n  });\n\n  const { data } = await postAptosFullNode<Uint8Array, Array<UserTransactionResponse>>({\n    aptosConfig,\n    body: signedTransaction,\n    path: \"transactions/simulate\",\n    params: {\n      estimate_gas_unit_price: args.options?.estimateGasUnitPrice ?? false,\n      estimate_max_gas_amount: args.options?.estimateMaxGasAmount ?? false,\n      estimate_prioritized_gas_unit_price: args.options?.estimatePrioritizedGasUnitPrice ?? false,\n    },\n    originMethod: \"simulateTransaction\",\n    contentType: MimeType.BCS_SIGNED_TRANSACTION,\n  });\n  return data;\n}\n\n/**\n * Submit transaction to chain\n *\n * @param args.transaction A aptos transaction type\n * @param args.senderAuthenticator The account authenticator of the transaction sender\n * @param args.secondarySignerAuthenticators optional. For when the transaction is a multi signers transaction\n *\n * @return PendingTransactionResponse\n */\nexport async function submitTransaction(\n  args: {\n    aptosConfig: AptosConfig;\n  } & InputSubmitTransactionData,\n): Promise<PendingTransactionResponse> {\n  const { aptosConfig } = args;\n  const signedTransaction = generateSignedTransaction({ ...args });\n  const { data } = await postAptosFullNode<Uint8Array, PendingTransactionResponse>({\n    aptosConfig,\n    body: signedTransaction,\n    path: \"transactions\",\n    originMethod: \"submitTransaction\",\n    contentType: MimeType.BCS_SIGNED_TRANSACTION,\n  });\n  return data;\n}\n\nexport async function signAndSubmitTransaction(args: {\n  aptosConfig: AptosConfig;\n  signer: Account;\n  transaction: AnyRawTransaction;\n}): Promise<PendingTransactionResponse> {\n  const { aptosConfig, signer, transaction } = args;\n  const authenticator = signTransaction({ signer, transaction });\n  return submitTransaction({\n    aptosConfig,\n    transaction,\n    senderAuthenticator: authenticator,\n  });\n}\n\nexport async function publicPackageTransaction(args: {\n  aptosConfig: AptosConfig;\n  account: AccountAddressInput;\n  metadataBytes: HexInput;\n  moduleBytecode: Array<HexInput>;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SingleSignerTransaction> {\n  const { aptosConfig, account, metadataBytes, moduleBytecode, options } = args;\n\n  const totalByteCode = moduleBytecode.map((bytecode) => MoveVector.U8(bytecode));\n\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: AccountAddress.fromRelaxed(account),\n    data: {\n      function: \"0x1::code::publish_package_txn\",\n      functionArguments: [MoveVector.U8(metadataBytes), new MoveVector(totalByteCode)],\n    },\n    options,\n  });\n  return transaction as SingleSignerTransaction;\n}\n\n/**\n * TODO: Need to refactor and move this function out of transactionSubmission\n */\nexport async function rotateAuthKey(args: {\n  aptosConfig: AptosConfig;\n  fromAccount: Account;\n  toNewPrivateKey: PrivateKey;\n}): Promise<TransactionResponse> {\n  const { aptosConfig, fromAccount, toNewPrivateKey } = args;\n  const accountInfo = await getInfo({\n    aptosConfig,\n    accountAddress: fromAccount.accountAddress,\n  });\n\n  const newAccount = Account.fromPrivateKey({ privateKey: toNewPrivateKey, legacy: true });\n\n  const challenge = new RotationProofChallenge({\n    sequenceNumber: BigInt(accountInfo.sequence_number),\n    originator: fromAccount.accountAddress,\n    currentAuthKey: AccountAddress.from(accountInfo.authentication_key),\n    newPublicKey: newAccount.publicKey,\n  });\n\n  // Sign the challenge\n  const challengeHex = challenge.bcsToBytes();\n  const proofSignedByCurrentPrivateKey = fromAccount.sign(challengeHex);\n  const proofSignedByNewPrivateKey = newAccount.sign(challengeHex);\n\n  // Generate transaction\n  const rawTxn = await generateTransaction({\n    aptosConfig,\n    sender: fromAccount.accountAddress,\n    data: {\n      function: \"0x1::account::rotate_authentication_key\",\n      functionArguments: [\n        new U8(fromAccount.signingScheme.valueOf()), // from scheme\n        MoveVector.U8(fromAccount.publicKey.toUint8Array()),\n        new U8(newAccount.signingScheme.valueOf()), // to scheme\n        MoveVector.U8(newAccount.publicKey.toUint8Array()),\n        MoveVector.U8(proofSignedByCurrentPrivateKey.toUint8Array()),\n        MoveVector.U8(proofSignedByNewPrivateKey.toUint8Array()),\n      ],\n    },\n  });\n  const pendingTxn = await signAndSubmitTransaction({\n    aptosConfig,\n    signer: fromAccount,\n    transaction: rawTxn,\n  });\n  return pendingTxn;\n}\n"],"mappings":"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","names":["generateTransaction","args","aptosConfig","sender","data","options","generateTransactionPayloadData","payload","generateTransactionPayload","feePayerAddress","isFeePayerTransactionInput","AccountAddress","isMultiAgentTransactionInput","secondarySignerAddresses","buildTransaction","signTransaction","sign","simulateTransaction","transaction","signerPublicKey","secondarySignersPublicKeys","feePayerPublicKey","signedTransaction","generateSignedTransactionForSimulation","postAptosFullNode","submitTransaction","generateSignedTransaction","signAndSubmitTransaction","signer","authenticator","publicPackageTransaction","account","metadataBytes","moduleBytecode","totalByteCode","bytecode","MoveVector","rotateAuthKey","fromAccount","toNewPrivateKey","accountInfo","getInfo","newAccount","Account","challengeHex","RotationProofChallenge","proofSignedByCurrentPrivateKey","proofSignedByNewPrivateKey","rawTxn","U8"]}
{"version":3,"sources":["../../src/core/authenticationKey.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { sha3_256 as sha3Hash } from \"@noble/hashes/sha3\";\nimport { AccountAddress } from \"./accountAddress\";\nimport { PublicKey } from \"./crypto/asymmetricCrypto\";\nimport { Ed25519PublicKey } from \"./crypto/ed25519\";\nimport { MultiEd25519PublicKey } from \"./crypto/multiEd25519\";\nimport { Hex } from \"./hex\";\nimport { AuthenticationKeyScheme, HexInput, SigningScheme } from \"../types\";\nimport { AnyPublicKey } from \"./crypto/anyPublicKey\";\nimport { MultiKey } from \"./crypto/multiKey\";\nimport { Serializable, Serializer } from \"../bcs/serializer\";\nimport { Deserializer } from \"../bcs/deserializer\";\n\n/**\n * Each account stores an authentication key. Authentication key enables account owners to rotate\n * their private key(s) associated with the account without changing the address that hosts their account.\n * @see {@link https://aptos.dev/concepts/accounts | Account Basics}\n *\n * Account addresses can be derived from AuthenticationKey\n */\nexport class AuthenticationKey extends Serializable {\n  /**\n   * An authentication key is always a SHA3-256 hash of data, and is always 32 bytes.\n   *\n   * The data to hash depends on the underlying public key type and the derivation scheme.\n   */\n  static readonly LENGTH: number = 32;\n\n  /**\n   * The raw bytes of the authentication key.\n   */\n  public readonly data: Hex;\n\n  constructor(args: { data: HexInput }) {\n    super();\n    const { data } = args;\n    const hex = Hex.fromHexInput(data);\n    if (hex.toUint8Array().length !== AuthenticationKey.LENGTH) {\n      throw new Error(`Authentication Key length should be ${AuthenticationKey.LENGTH}`);\n    }\n    this.data = hex;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeFixedBytes(this.data.toUint8Array());\n  }\n\n  /**\n   * Deserialize an AuthenticationKey from the byte buffer in a Deserializer instance.\n   * @param deserializer The deserializer to deserialize the AuthenticationKey from.\n   * @returns An instance of AuthenticationKey.\n   */\n  static deserialize(deserializer: Deserializer): AuthenticationKey {\n    const bytes = deserializer.deserializeFixedBytes(AuthenticationKey.LENGTH);\n    return new AuthenticationKey({ data: bytes });\n  }\n\n  toString(): string {\n    return this.data.toString();\n  }\n\n  toUint8Array(): Uint8Array {\n    return this.data.toUint8Array();\n  }\n\n  /**\n   * Derives an AuthenticationKey from the public key seed bytes and an explicit derivation scheme.\n   *\n   * This facilitates targeting a specific scheme for deriving an authentication key from a public key.\n   *\n   * @param args - the public key and scheme to use for the derivation\n   */\n  public static fromPublicKeyAndScheme(args: { publicKey: PublicKey; scheme: AuthenticationKeyScheme }) {\n    const { publicKey, scheme } = args;\n    let authKeyBytes: Uint8Array;\n\n    switch (scheme) {\n      case SigningScheme.MultiKey:\n      case SigningScheme.SingleKey: {\n        const singleKeyBytes = publicKey.bcsToBytes();\n        authKeyBytes = new Uint8Array([...singleKeyBytes, scheme]);\n        break;\n      }\n\n      case SigningScheme.Ed25519:\n      case SigningScheme.MultiEd25519: {\n        const ed25519PublicKeyBytes = publicKey.toUint8Array();\n        const inputBytes = Hex.fromHexInput(ed25519PublicKeyBytes).toUint8Array();\n        authKeyBytes = new Uint8Array([...inputBytes, scheme]);\n        break;\n      }\n\n      default:\n        throw new Error(`Scheme ${scheme} is not supported`);\n    }\n\n    const hash = sha3Hash.create();\n    hash.update(authKeyBytes);\n    const hashDigest = hash.digest();\n    return new AuthenticationKey({ data: hashDigest });\n  }\n\n  /**\n   * Converts a PublicKey(s) to an AuthenticationKey, using the derivation scheme inferred from the\n   * instance of the PublicKey type passed in.\n   *\n   * @param args.publicKey\n   * @returns AuthenticationKey\n   */\n  static fromPublicKey(args: { publicKey: PublicKey }): AuthenticationKey {\n    const { publicKey } = args;\n\n    let scheme: number;\n    if (publicKey instanceof Ed25519PublicKey) {\n      // for legacy support\n      scheme = SigningScheme.Ed25519.valueOf();\n    } else if (publicKey instanceof MultiEd25519PublicKey) {\n      // for legacy support\n      scheme = SigningScheme.MultiEd25519.valueOf();\n    } else if (publicKey instanceof AnyPublicKey) {\n      scheme = SigningScheme.SingleKey.valueOf();\n    } else if (publicKey instanceof MultiKey) {\n      scheme = SigningScheme.MultiKey.valueOf();\n    } else {\n      throw new Error(\"No supported authentication scheme for public key\");\n    }\n\n    return AuthenticationKey.fromPublicKeyAndScheme({ publicKey, scheme });\n  }\n\n  /**\n   * Derives an account address from an AuthenticationKey. Since an AccountAddress is also 32 bytes,\n   * the AuthenticationKey bytes are directly translated to an AccountAddress.\n   *\n   * @returns AccountAddress\n   */\n  derivedAddress(): AccountAddress {\n    return new AccountAddress(this.data.toUint8Array());\n  }\n}\n"],"mappings":"+RAGA,OAAS,YAAYA,MAAgB,qBAmB9B,IAAMC,EAAN,MAAMA,UAA0BC,CAAa,CAalD,YAAYC,EAA0B,CACpC,MAAM,EACN,GAAM,CAAE,KAAAC,CAAK,EAAID,EACXE,EAAMC,EAAI,aAAaF,CAAI,EACjC,GAAIC,EAAI,aAAa,EAAE,SAAWJ,EAAkB,OAClD,MAAM,IAAI,MAAM,uCAAuCA,EAAkB,MAAM,EAAE,EAEnF,KAAK,KAAOI,CACd,CAEA,UAAUE,EAA8B,CACtCA,EAAW,oBAAoB,KAAK,KAAK,aAAa,CAAC,CACzD,CAOA,OAAO,YAAYC,EAA+C,CAChE,IAAMC,EAAQD,EAAa,sBAAsBP,EAAkB,MAAM,EACzE,OAAO,IAAIA,EAAkB,CAAE,KAAMQ,CAAM,CAAC,CAC9C,CAEA,UAAmB,CACjB,OAAO,KAAK,KAAK,SAAS,CAC5B,CAEA,cAA2B,CACzB,OAAO,KAAK,KAAK,aAAa,CAChC,CASA,OAAc,uBAAuBN,EAAiE,CACpG,GAAM,CAAE,UAAAO,EAAW,OAAAC,CAAO,EAAIR,EAC1BS,EAEJ,OAAQD,EAAQ,CACd,OACA,OAA8B,CAC5B,IAAME,EAAiBH,EAAU,WAAW,EAC5CE,EAAe,IAAI,WAAW,CAAC,GAAGC,EAAgBF,CAAM,CAAC,EACzD,KACF,CAEA,OACA,OAAiC,CAC/B,IAAMG,EAAwBJ,EAAU,aAAa,EAC/CK,EAAaT,EAAI,aAAaQ,CAAqB,EAAE,aAAa,EACxEF,EAAe,IAAI,WAAW,CAAC,GAAGG,EAAYJ,CAAM,CAAC,EACrD,KACF,CAEA,QACE,MAAM,IAAI,MAAM,UAAUA,CAAM,mBAAmB,CACvD,CAEA,IAAMK,EAAOC,EAAS,OAAO,EAC7BD,EAAK,OAAOJ,CAAY,EACxB,IAAMM,EAAaF,EAAK,OAAO,EAC/B,OAAO,IAAIf,EAAkB,CAAE,KAAMiB,CAAW,CAAC,CACnD,CASA,OAAO,cAAcf,EAAmD,CACtE,GAAM,CAAE,UAAAO,CAAU,EAAIP,EAElBQ,EACJ,GAAID,aAAqBS,EAEvBR,KAA+B,QAAQ,UAC9BD,aAAqBU,EAE9BT,KAAoC,QAAQ,UACnCD,aAAqBW,EAC9BV,KAAiC,QAAQ,UAChCD,aAAqBY,EAC9BX,KAAgC,QAAQ,MAExC,OAAM,IAAI,MAAM,mDAAmD,EAGrE,OAAOV,EAAkB,uBAAuB,CAAE,UAAAS,EAAW,OAAAC,CAAO,CAAC,CACvE,CAQA,gBAAiC,CAC/B,OAAO,IAAIY,EAAe,KAAK,KAAK,aAAa,CAAC,CACpD,CACF,EAvHatB,EAMK,OAAiB,GAN5B,IAAMuB,EAANvB","names":["sha3Hash","_AuthenticationKey","Serializable","args","data","hex","Hex","serializer","deserializer","bytes","publicKey","scheme","authKeyBytes","singleKeyBytes","ed25519PublicKeyBytes","inputBytes","hash","sha3Hash","hashDigest","Ed25519PublicKey","MultiEd25519PublicKey","AnyPublicKey","MultiKey","AccountAddress","AuthenticationKey"]}